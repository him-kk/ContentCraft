const mongoose = require('mongoose');

const AudiencePersonaSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    name: {
      type: String,
      required: true,
    },
    avatar: String,
    description: String,
    isAutoGenerated: {
      type: Boolean,
      default: false,
    },
    sourcePlatforms: [{
      platform: {
        type: String,
        enum: ['twitter', 'linkedin', 'instagram', 'facebook', 'tiktok', 'youtube'],
      },
      dataPoints: Number,
      lastAnalyzed: Date,
    }],
    demographics: {
      ageRange: {
        min: Number,
        max: Number,
      },
      gender: {
        type: String,
        enum: ['male', 'female', 'non-binary', 'unknown'],
      },
      locations: [{
        country: String,
        city: String,
        percentage: Number,
      }],
      languages: [String],
      education: [String],
      income: {
        range: String,
        currency: String,
      },
      occupation: [String],
      industries: [String],
    },
    psychographics: {
      interests: [{
        name: String,
        affinity: Number, // 0-100
      }],
      values: [String],
      personality: {
        type: String,
        enum: ['innovator', 'early_adopter', 'early_majority', 'late_majority', 'laggard'],
      },
      lifestyle: [String],
      goals: [String],
      challenges: [String],
    },
    behavior: {
      activeHours: [{
        day: String,
        hours: [Number], // 0-23
      }],
      preferredContentTypes: [{
        type: String,
        percentage: Number,
      }],
      engagementPatterns: {
        likesFrequency: String,
        commentFrequency: String,
        shareFrequency: String,
        clickThroughRate: Number,
      },
      deviceUsage: {
        mobile: Number,
        desktop: Number,
        tablet: Number,
      },
      purchaseBehavior: {
        frequency: String,
        avgOrderValue: Number,
        preferredChannels: [String],
        decisionFactors: [String],
      },
    },
    painPoints: [{
      description: String,
      severity: {
        type: Number,
        min: 1,
        max: 10,
      },
      relatedTopics: [String],
    }],
    contentPreferences: {
      topics: [{
        name: String,
        interest: Number,
      }],
      formats: [{
        type: String,
        preference: Number,
      }],
      tone: [String],
      length: {
        type: String,
        enum: ['short', 'medium', 'long', 'mixed'],
      },
      frequency: String,
    },
    influence: {
      followers: {
        min: Number,
        max: Number,
      },
      following: {
        min: Number,
        max: Number,
      },
      engagementRate: Number,
      isInfluencer: {
        type: Boolean,
        default: false,
      },
      influenceScore: {
        type: Number,
        min: 0,
        max: 100,
      },
    },
    purchaseIntent: {
      score: {
        type: Number,
        min: 0,
        max: 100,
      },
      stage: {
        type: String,
        enum: ['awareness', 'consideration', 'decision', 'purchase', 'loyalty'],
      },
      priceSensitivity: {
        type: Number,
        min: 0,
        max: 100,
      },
      brandLoyalty: {
        type: Number,
        min: 0,
        max: 100,
      },
    },
    segmentSize: {
      absolute: Number,
      percentage: Number,
    },
    contentGaps: [{
      topic: String,
      demand: Number,
      supply: Number,
      opportunity: Number,
    }],
    recommendedMessaging: [{
      context: String,
      message: String,
      tone: String,
      expectedEngagement: Number,
    }],
    performance: {
      contentCreated: { type: Number, default: 0 },
      avgEngagement: { type: Number, default: 0 },
      conversionRate: { type: Number, default: 0 },
    },
    isActive: {
      type: Boolean,
      default: true,
    },
    lastAnalyzed: {
      type: Date,
      default: Date.now,
    },
  },
  {
    timestamps: true,
  }
);

// Indexes
AudiencePersonaSchema.index({ user: 1 });
AudiencePersonaSchema.index({ isActive: 1 });
AudiencePersonaSchema.index({ 'demographics.ageRange.min': 1, 'demographics.ageRange.max': 1 });

// Static method to get personas by user
AudiencePersonaSchema.statics.getByUser = async function (userId) {
  return this.find({
    user: userId,
    isActive: true,
  }).sort({ createdAt: -1 });
};

// Static method to get top personas by engagement
AudiencePersonaSchema.statics.getTopByEngagement = async function (userId, limit = 5) {
  return this.find({
    user: userId,
    isActive: true,
  })
    .sort({ 'performance.avgEngagement': -1 })
    .limit(limit);
};

// Method to update performance metrics
AudiencePersonaSchema.methods.updatePerformance = async function (engagement, conversion = 0) {
  const totalContent = this.performance.contentCreated + 1;
  this.performance.avgEngagement = 
    ((this.performance.avgEngagement * this.performance.contentCreated) + engagement) / totalContent;
  this.performance.contentCreated = totalContent;
  
  if (conversion > 0) {
    this.performance.conversionRate = 
      ((this.performance.conversionRate * (totalContent - 1)) + conversion) / totalContent;
  }
  
  await this.save();
};

// Method to get best posting times
AudiencePersonaSchema.methods.getBestPostingTimes = function () {
  const bestTimes = [];
  
  this.behavior.activeHours.forEach(dayData => {
    const peakHours = dayData.hours
      .map((activity, hour) => ({ hour, activity }))
      .sort((a, b) => b.activity - a.activity)
      .slice(0, 3);
    
    bestTimes.push({
      day: dayData.day,
      hours: peakHours.map(h => h.hour),
    });
  });
  
  return bestTimes;
};

module.exports = mongoose.model('AudiencePersona', AudiencePersonaSchema);