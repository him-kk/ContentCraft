const { GoogleGenerativeAI } = require('@google/generative-ai');
const AudiencePersona = require('../models/AudiencePersona');
const Content = require('../models/Content');
const Analytics = require('../models/Analytics');
const logger = require('../utils/logger');

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

class AudienceService {
  // Generate audience personas from data
  async generatePersonas(userId, platformData = {}) {
    try {
      const model = genAI.getGenerativeModel({ model: 'gemini-pro' });

      // Get user's content performance data
      const contentData = await Content.find({
        user: userId,
        status: 'published',
      })
        .sort({ createdAt: -1 })
        .limit(50)
        .select('performance platform type tags tone');

      // Get analytics data
      const analyticsData = await Analytics.find({ user: userId })
        .sort({ date: -1 })
        .limit(30);

      const prompt = `Analyze this content performance data and create 3-5 detailed audience personas.

Content Performance:
${JSON.stringify(contentData.map(c => ({
  platform: c.platform,
  type: c.type,
  tags: c.tags,
  engagement: c.performance,
})))}

Platform Data:
${JSON.stringify(platformData)}

For each persona, provide:
{
  "name": "descriptive name (e.g., 'Tech-Savvy Startup Founder')",
  "description": "brief overview",
  "demographics": {
    "ageRange": { "min": 25, "max": 35 },
    "gender": "male|female|non-binary|unknown",
    "locations": [{ "country": "US", "percentage": 60 }],
    "occupation": ["roles"],
    "industries": ["industries"],
    "income": { "range": "$50k-$100k", "currency": "USD" }
  },
  "psychographics": {
    "interests": [{ "name": "interest", "affinity": 85 }],
    "values": ["value1", "value2"],
    "personality": "innovator|early_adopter|etc",
    "goals": ["goal1", "goal2"],
    "challenges": ["challenge1", "challenge2"]
  },
  "behavior": {
    "activeHours": [{ "day": "Monday", "hours": [9, 10, 11, 12, 20, 21] }],
    "preferredContentTypes": [{ "type": "blog", "percentage": 40 }],
    "engagementPatterns": { "likesFrequency": "high", "commentFrequency": "medium" },
    "deviceUsage": { "mobile": 60, "desktop": 35, "tablet": 5 }
  },
  "painPoints": [{ "description": "pain point", "severity": 8 }],
  "contentPreferences": {
    "topics": [{ "name": "topic", "interest": 90 }],
    "formats": [{ "type": "video", "preference": 80 }],
    "tone": ["professional", "friendly"],
    "length": "medium"
  },
  "purchaseIntent": { "score": 75, "stage": "consideration", "priceSensitivity": 40 }
}

Respond with a JSON array of personas.`;

      const result = await model.generateContent(prompt);
      const responseText = result.response.text();

      let personas;
      try {
        const jsonMatch = responseText.match(/\[[\s\S]*\]/);
        personas = JSON.parse(jsonMatch ? jsonMatch[0] : responseText);
      } catch (parseError) {
        logger.error('Persona parse error:', parseError);
        personas = this.generateDefaultPersonas();
      }

      // Save personas to database
      const savedPersonas = [];
      for (const personaData of personas) {
        const persona = await AudiencePersona.create({
          user: userId,
          ...personaData,
          isAutoGenerated: true,
          lastAnalyzed: new Date(),
        });
        savedPersonas.push(persona);
      }

      return {
        success: true,
        personas: savedPersonas,
        count: savedPersonas.length,
      };
    } catch (error) {
      logger.error('Generate personas error:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  // Analyze audience behavior patterns
  async analyzeBehaviorPatterns(userId, personaId = null) {
    try {
      const query = { user: userId };
      if (personaId) query._id = personaId;

      const personas = await AudiencePersona.find(query);

      const analysis = {
        peakActivityTimes: this.calculatePeakTimes(personas),
        contentPreferences: this.aggregateContentPreferences(personas),
        engagementPatterns: this.aggregateEngagementPatterns(personas),
        deviceBreakdown: this.calculateDeviceBreakdown(personas),
        geographicDistribution: this.aggregateGeography(personas),
      };

      return {
        success: true,
        analysis,
        personas: personas.map(p => ({
          id: p._id,
          name: p.name,
          segmentSize: p.segmentSize,
        })),
      };
    } catch (error) {
      logger.error('Behavior analysis error:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  // Identify pain points
  async identifyPainPoints(userId) {
    try {
      const personas = await AudiencePersona.find({ user: userId });

      const allPainPoints = [];
      for (const persona of personas) {
        for (const painPoint of persona.painPoints) {
          allPainPoints.push({
            persona: persona.name,
            ...painPoint.toObject(),
          });
        }
      }

      // Group and rank pain points
      const grouped = this.groupPainPoints(allPainPoints);

      return {
        success: true,
        painPoints: grouped,
        topPainPoints: grouped.slice(0, 5),
        contentOpportunities: this.suggestPainPointContent(grouped),
      };
    } catch (error) {
      logger.error('Pain points error:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  // Find content gaps
  async findContentGaps(userId) {
    try {
      const personas = await AudiencePersona.find({ user: userId });
      const existingContent = await Content.find({
        user: userId,
        status: { $in: ['published', 'scheduled'] },
      }).select('tags type title');

      const model = genAI.getGenerativeModel({ model: 'gemini-pro' });

      const prompt = `Analyze audience interests and existing content to identify content gaps.

Audience Interests:
${JSON.stringify(personas.flatMap(p => p.contentPreferences.topics))}

Existing Content Topics:
${JSON.stringify(existingContent.map(c => ({ title: c.title, tags: c.tags, type: c.type })))}

Identify:
1. High-interest topics with low content coverage
2. Emerging topics audience might be interested in
3. Content formats that are underutilized
4. Questions/problems not adequately addressed

Respond in JSON format:
{
  "gaps": [
    {
      "topic": "topic name",
      "demand": 1-100,
      "supply": 1-100,
      "opportunity": 1-100,
      "recommendedFormat": "blog|video|infographic|etc",
      "contentIdeas": ["idea1", "idea2"]
    }
  ],
  "prioritizedGaps": ["gap1", "gap2"],
  "recommendedContentCalendar": [{ "topic": "topic", "priority": "high", "timeline": "1 week" }]
}`;

      const result = await model.generateContent(prompt);
      const responseText = result.response.text();

      let gaps;
      try {
        const jsonMatch = responseText.match(/\{[\s\S]*\}/);
        gaps = JSON.parse(jsonMatch ? jsonMatch[0] : responseText);
      } catch {
        gaps = { gaps: [], prioritizedGaps: [], recommendedContentCalendar: [] };
      }

      return {
        success: true,
        ...gaps,
      };
    } catch (error) {
      logger.error('Content gaps error:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  // Get demographic breakdown
  async getDemographics(userId) {
    try {
      const personas = await AudiencePersona.find({ user: userId });

      const demographics = {
        ageDistribution: this.calculateAgeDistribution(personas),
        genderDistribution: this.calculateGenderDistribution(personas),
        locationDistribution: this.calculateLocationDistribution(personas),
        occupationDistribution: this.calculateOccupationDistribution(personas),
        incomeDistribution: this.calculateIncomeDistribution(personas),
        educationDistribution: this.calculateEducationDistribution(personas),
      };

      return {
        success: true,
        demographics,
        totalAudience: personas.reduce((sum, p) => sum + (p.segmentSize?.absolute || 0), 0),
      };
    } catch (error) {
      logger.error('Demographics error:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  // Get personality profile
  async getPersonalityProfile(userId) {
    try {
      const personas = await AudiencePersona.find({ user: userId });

      const personalityTypes = {
        innovator: 0,
        early_adopter: 0,
        early_majority: 0,
        late_majority: 0,
        laggard: 0,
      };

      for (const persona of personas) {
        const type = persona.psychographics?.personality;
        if (type && personalityTypes[type] !== undefined) {
          personalityTypes[type] += persona.segmentSize?.percentage || 0;
        }
      }

      return {
        success: true,
        personalityProfile: personalityTypes,
        dominantType: Object.entries(personalityTypes)
          .sort((a, b) => b[1] - a[1])[0][0],
        interpretation: this.interpretPersonalityProfile(personalityTypes),
      };
    } catch (error) {
      logger.error('Personality profile error:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  // Create audience segments
  async createSegments(userId, segmentCriteria) {
    try {
      const personas = await AudiencePersona.find({ user: userId });
      const segments = [];

      for (const criteria of segmentCriteria) {
        const matchingPersonas = personas.filter(p => {
          // Apply filter criteria
          if (criteria.ageRange) {
            const age = p.demographics?.ageRange;
            if (age && (age.min > criteria.ageRange.max || age.max < criteria.ageRange.min)) {
              return false;
            }
          }
          if (criteria.interests?.length > 0) {
            const interests = p.psychographics?.interests?.map(i => i.name) || [];
            if (!criteria.interests.some(i => interests.includes(i))) {
              return false;
            }
          }
          if (criteria.locations?.length > 0) {
            const locations = p.demographics?.locations?.map(l => l.country) || [];
            if (!criteria.locations.some(l => locations.includes(l))) {
              return false;
            }
          }
          return true;
        });

        if (matchingPersonas.length > 0) {
          segments.push({
            name: criteria.name,
            criteria,
            personas: matchingPersonas.map(p => p._id),
            estimatedSize: matchingPersonas.reduce((sum, p) => sum + (p.segmentSize?.absolute || 0), 0),
            percentage: matchingPersonas.reduce((sum, p) => sum + (p.segmentSize?.percentage || 0), 0),
          });
        }
      }

      return {
        success: true,
        segments,
        count: segments.length,
      };
    } catch (error) {
      logger.error('Create segments error:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  // Get purchase intent scores
  async getPurchaseIntent(userId) {
    try {
      const personas = await AudiencePersona.find({ user: userId });

      const intentDistribution = {
        awareness: [],
        consideration: [],
        decision: [],
        purchase: [],
        loyalty: [],
      };

      let totalScore = 0;
      let totalSize = 0;

      for (const persona of personas) {
        const intent = persona.purchaseIntent;
        if (intent) {
          intentDistribution[intent.stage]?.push({
            persona: persona.name,
            score: intent.score,
            size: persona.segmentSize?.percentage || 0,
          });
          totalScore += intent.score * (persona.segmentSize?.percentage || 0);
          totalSize += persona.segmentSize?.percentage || 0;
        }
      }

      const averageIntent = totalSize > 0 ? totalScore / totalSize : 0;

      return {
        success: true,
        intentDistribution,
        averageIntentScore: averageIntent.toFixed(1),
        readyToBuy: intentDistribution.decision.length + intentDistribution.purchase.length,
        needNurturing: intentDistribution.awareness.length + intentDistribution.consideration.length,
      };
    } catch (error) {
      logger.error('Purchase intent error:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  // Track audience evolution
  async trackEvolution(userId, months = 6) {
    try {
      // Get historical persona data
      const since = new Date(Date.now() - months * 30 * 24 * 60 * 60 * 1000);
      
      const currentPersonas = await AudiencePersona.find({ user: userId });
      
      // In production, compare with historical snapshots
      // For now, generate evolution insights

      const evolution = {
        period: `${months} months`,
        currentSnapshot: {
          totalPersonas: currentPersonas.length,
          dominantInterests: this.getDominantInterests(currentPersonas),
          growingSegments: this.identifyGrowingSegments(currentPersonas),
          decliningSegments: this.identifyDecliningSegments(currentPersonas),
        },
        trends: [
          'Increased interest in AI-related content',
          'Shift toward video content consumption',
          'Growing mobile audience',
        ],
        predictions: [
          'AI and automation topics will continue growing',
          'Short-form video preference will increase',
          'International audience will expand',
        ],
      };

      return {
        success: true,
        evolution,
      };
    } catch (error) {
      logger.error('Track evolution error:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  // Helper methods
  calculatePeakTimes(personas) {
    const hourActivity = Array(24).fill(0);
    
    for (const persona of personas) {
      for (const dayData of persona.behavior?.activeHours || []) {
        for (const hour of dayData.hours || []) {
          hourActivity[hour] += persona.segmentSize?.percentage || 1;
        }
      }
    }

    const peakHours = hourActivity
      .map((activity, hour) => ({ hour, activity }))
      .sort((a, b) => b.activity - a.activity)
      .slice(0, 5);

    return peakHours;
  }

  aggregateContentPreferences(personas) {
    const preferences = {};
    
    for (const persona of personas) {
      for (const pref of persona.contentPreferences?.topics || []) {
        preferences[pref.name] = (preferences[pref.name] || 0) + pref.interest;
      }
    }

    return Object.entries(preferences)
      .map(([name, interest]) => ({ name, interest: interest / personas.length }))
      .sort((a, b) => b.interest - a.interest);
  }

  aggregateEngagementPatterns(personas) {
    const patterns = {
      likesFrequency: { high: 0, medium: 0, low: 0 },
      commentFrequency: { high: 0, medium: 0, low: 0 },
      shareFrequency: { high: 0, medium: 0, low: 0 },
    };

    for (const persona of personas) {
      const engagement = persona.behavior?.engagementPatterns;
      if (engagement) {
        patterns.likesFrequency[engagement.likesFrequency]++;
        patterns.commentFrequency[engagement.commentFrequency]++;
        patterns.shareFrequency[engagement.shareFrequency]++;
      }
    }

    return patterns;
  }

  calculateDeviceBreakdown(personas) {
    const breakdown = { mobile: 0, desktop: 0, tablet: 0 };
    
    for (const persona of personas) {
      const devices = persona.behavior?.deviceUsage;
      if (devices) {
        breakdown.mobile += devices.mobile * (persona.segmentSize?.percentage || 0) / 100;
        breakdown.desktop += devices.desktop * (persona.segmentSize?.percentage || 0) / 100;
        breakdown.tablet += devices.tablet * (persona.segmentSize?.percentage || 0) / 100;
      }
    }

    return breakdown;
  }

  aggregateGeography(personas) {
    const locations = {};
    
    for (const persona of personas) {
      for (const loc of persona.demographics?.locations || []) {
        locations[loc.country] = (locations[loc.country] || 0) + loc.percentage;
      }
    }

    return Object.entries(locations)
      .map(([country, percentage]) => ({ country, percentage }))
      .sort((a, b) => b.percentage - a.percentage);
  }

  groupPainPoints(painPoints) {
    const grouped = {};
    
    for (const pp of painPoints) {
      const key = pp.description.toLowerCase();
      if (!grouped[key]) {
        grouped[key] = { ...pp, count: 0, personas: [] };
      }
      grouped[key].count++;
      grouped[key].personas.push(pp.persona);
    }

    return Object.values(grouped)
      .sort((a, b) => b.severity * b.count - a.severity * a.count);
  }

  suggestPainPointContent(painPoints) {
    return painPoints.slice(0, 5).map(pp => ({
      painPoint: pp.description,
      contentIdeas: [
        `How to overcome ${pp.description.toLowerCase()}`,
        `5 solutions for ${pp.description.toLowerCase()}`,
        `The ultimate guide to solving ${pp.description.toLowerCase()}`,
      ],
      targetPersonas: pp.personas,
    }));
  }

  calculateAgeDistribution(personas) {
    const distribution = {};
    
    for (const persona of personas) {
      const age = persona.demographics?.ageRange;
      if (age) {
        const key = `${age.min}-${age.max}`;
        distribution[key] = (distribution[key] || 0) + (persona.segmentSize?.percentage || 0);
      }
    }

    return distribution;
  }

  calculateGenderDistribution(personas) {
    const distribution = { male: 0, female: 0, 'non-binary': 0, unknown: 0 };
    
    for (const persona of personas) {
      const gender = persona.demographics?.gender;
      if (gender) {
        distribution[gender] += persona.segmentSize?.percentage || 0;
      }
    }

    return distribution;
  }

  calculateLocationDistribution(personas) {
    return this.aggregateGeography(personas);
  }

  calculateOccupationDistribution(personas) {
    const distribution = {};
    
    for (const persona of personas) {
      for (const occ of persona.demographics?.occupation || []) {
        distribution[occ] = (distribution[occ] || 0) + (persona.segmentSize?.percentage || 0);
      }
    }

    return distribution;
  }

  calculateIncomeDistribution(personas) {
    const distribution = {};
    
    for (const persona of personas) {
      const income = persona.demographics?.income?.range;
      if (income) {
        distribution[income] = (distribution[income] || 0) + (persona.segmentSize?.percentage || 0);
      }
    }

    return distribution;
  }

  calculateEducationDistribution(personas) {
    const distribution = {};
    
    for (const persona of personas) {
      for (const edu of persona.demographics?.education || []) {
        distribution[edu] = (distribution[edu] || 0) + (persona.segmentSize?.percentage || 0);
      }
    }

    return distribution;
  }

  interpretPersonalityProfile(profile) {
    const dominant = Object.entries(profile).sort((a, b) => b[1] - a[1])[0];
    
    const interpretations = {
      innovator: 'Your audience is eager to try new things and be first. Focus on cutting-edge content.',
      early_adopter: 'Your audience is trend-aware and influential. Leverage emerging trends.',
      early_majority: 'Your audience values proven solutions. Use testimonials and case studies.',
      late_majority: 'Your audience is cautious. Emphasize reliability and support.',
      laggard: 'Your audience is traditional. Focus on established methods and gradual change.',
    };

    return interpretations[dominant[0]] || 'Mixed audience - diversify content approach.';
  }

  getDominantInterests(personas) {
    const interests = {};
    
    for (const persona of personas) {
      for (const interest of persona.psychographics?.interests || []) {
        interests[interest.name] = (interests[interest.name] || 0) + interest.affinity;
      }
    }

    return Object.entries(interests)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([name]) => name);
  }

  identifyGrowingSegments(personas) {
    // In production, compare with historical data
    return personas
      .filter(p => p.performance?.avgEngagement > 5)
      .map(p => p.name);
  }

  identifyDecliningSegments(personas) {
    // In production, compare with historical data
    return [];
  }

  generateDefaultPersonas() {
    return [
      {
        name: 'Tech-Savvy Professional',
        description: 'Early adopter of technology, values efficiency and innovation',
        demographics: {
          ageRange: { min: 25, max: 40 },
          gender: 'unknown',
          locations: [{ country: 'US', percentage: 50 }],
        },
        psychographics: {
          interests: [{ name: 'Technology', affinity: 90 }],
          personality: 'innovator',
        },
      },
    ];
  }
}

module.exports = new AudienceService();